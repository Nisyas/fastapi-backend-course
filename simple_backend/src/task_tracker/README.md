<!-- 
1) Прочитайте, что такое "Хранение состояния", создайте в task_tracker readme.md файл и напишите в чём минусы подхода с хранением задач в оперативной памяти (списке python)
2) что улучшилось после того, как список из оперативной памяти изменился на файл проекта?
3) избавились ли мы таким способом от хранения состояния или нет?
4) где еще можно хранить задачи и какие есть преимущества и недостатки этих подходов?
5) Прочитайте что такое "состояние гонки" и напишите в readme файле о том, какие проблемы остались в бекенде на данном этапе проекта. 
Есть ли у вас какое-то решение этой проблемы? 
-->

<!-- 
1) Если хранить данные в оперативной памяти, то они будут сущестовать только пока программа работает, при её закрытии все данные пропадут, 
а нам нужно чтобы наши задачи сохранялись и после закрытия программы. Это и есть основной минус хранения списка задач в оперативной памяти
2) После того, как мы создали файл для хранения данных, наш проект получил постоянное хранилище данных, которе сохраняет информацию вне зависимости 
от того работает ли в данный момент программа или нет.
3) Хранение состояния это способ того, как программе нужно хранить данные. Можно сказать, что теперь хранение состояния списка с задачами
находится в отдельном файле. Что позволяет нашей программе "помнить" список задач даже после перезапуска.
4)  -Можно хранить задачи в локальной базе данных типо SQLite, такие файлы нейдобно шарить по сети(указать почему), гонку в пределах одного
        компьютера можно решить с помощью транзакций
    - Можно использовать полноценную серверную базу данных типо PostgreSQL/MySQL. Есть все те де плюсы, что и у локальной БД, но такое
        решение ещё создаёт резервные копии и проще открыть общий доступ с любого устройства к списку задач. Но такие БД платные
    - Облачное хранилище. Его просто использовать, оно бесплатное, но есть ограничение в количестве памяти которое может занять файл.
        Решить проблему состояние гонки с таким решением будет сложнее

5) Состояние гонки - это ошибка при которой результат выполнения программы зависит от порядка запросов. На примере нашего таск трекера
если два пользователя попробуют внести изменения в таску с одинаковым id, то запишутся те изменения которые были последними. Чтобы решить эту проблему
в нашем приложении можно использовать базу данных с транзакциями. Так же можно добавить версионирование записей или блокировать запросы на уровне Gist
через ETag 
-->